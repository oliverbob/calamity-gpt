{
	println: println
	default: default
	slice: slice
	map: map
	append: append
} := import('std')
{
	endsWith?: endsWith?
} := import('str')

json := import('json')
{
	Renderer: Renderer
	h: h
} := import('../lib/torus.js')

DefaultTokens := 20
DefaultN := 5

State := {
	fetching?: false
	params: {
		// mirrors the parameter names used in the GPT2 API
		tokens: DefaultTokens
		n: DefaultN
	}
	docIdx: 0
	docs: [{
		prompt: 'Today, I will finally s'
		completions: []
	}]
	// TODO: to try...
	// topic extraction
	// mailing list archive format
}

fn fetchCompletion(prompt, withCompletions) {
	render(State.fetching? := true)

	resp := with fetch('/gen') {
		method: 'POST'
		body: json.serialize({
			text: prompt
			tokens: State.params.tokens
			n: State.params.n
		})
	}

	fn handleErr(e) {
		render(State.fetching? := '(error: ' + bind(e, :toString)() + ')')
	}

	bind(resp, :catch)(handleErr)
	jsonResp := with bind(resp, :then)() fn(r) if r.status {
		200 -> bind(r, :json)()
		_ -> handleErr('Request failed.')
	}

	bind(jsonResp, :catch)(handleErr)
	with bind(jsonResp, :then)() fn(data) if data {
		? -> handleErr('Request serialization failed.')
		_ -> {
			render(State.fetching? := false)
			withCompletions(data)
		}
	}
}

fn updateCompletions() if State.fetching? {
	true -> ?
	_ -> with fetchCompletion(currentDoc().prompt) fn(completions) {
		doc := currentDoc()
		doc.completions := completions |> with map() fn(completion) [
			doc.prompt
			completion |> slice(len(doc.prompt))
		]
		render()
	}
}

fn currentDoc() if doc := State.docs.(State.docIdx) {
	? -> State.docs.(State.docIdx := 0)
	_ -> doc
}

fn truncate(s, n) if len(s) < n {
	true -> s
	_ -> s |> slice(0, n) + '...'
}

r := Renderer('#root')

fn render {
	with r.update() h(:div, ['app'], [
		h(:div, ['sidebar'], [
			h(:div, ['logo'], [
				h(:a, [], { href: '/' }, [
					'Calamity'
					h(:span, ['logo-faded'], [', a notebook'])
				])
			])
			h(:div, ['docs-list-container'], [
				h(:ul, ['docs-list'], {
					addDocButton := h(:li, ['floating', 'inactive', 'docs-item', 'new-doc-button'], {}, {
						click: fn {
							State.docs := [{ prompt: '', completions: [] }] |> append(State.docs)
							State.docIdx := 0
							render()

							// TODO: focus the new doc
						}
					}, ['+ New transcript'])

					docItems := State.docs |> with map() fn(doc, i) h(
						:li
						[
							'floating'
							'docs-item'
							if State.docIdx {
								i -> 'active'
								_ -> 'inactive'
							}
							if doc.prompt {
								'' -> 'empty'
								_ -> ''
							}
						]
						{}
						{
							click: fn {
								State.docIdx := i
								render()
							}
						}
						[
							if doc.prompt {
								'' -> 'empty'
								_ -> doc.prompt |> truncate(100)
							}
						]
					)

					[addDocButton] |> append(docItems)
				})
			])
			h(:nav, [], [
				h(:a, [], { href: '/about/' }, ['about'])
			])
		])
		h(:main, [], [
			{
				prompt := currentDoc().prompt
				h(:div, ['editor-container'], [
					h(:div, [
						'floating', 'inactive', 'editor-shadow'
						if prompt |> endsWith?('\n') {
							true -> 'extra-height'
							_ -> ''
						}
					], [prompt])
					h(:textarea, ['floating', 'editor-itself'], {
						value: prompt
						placeholder: 'Start a prompt...'
					}, {
						input: fn(evt) {
							currentDoc().prompt := evt.target.value
							render()
						}
						keydown: fn(evt) if [evt.key, evt.ctrlKey | evt.metaKey] {
							['Enter', true] -> updateCompletions()
						}
					}, [])
				])
			}
			h(:div, ['ai-controls'], [
				h(:div, ['left'], [
					h(:label, [], [
						h(:span, ['label-text'], ['Tokens'])
						h(:input, ['floating'], {
							type: 'number'
							min: '1'
							max: '200'
							value: State.params.tokens
						}, {
							input: fn(evt) {
								State.params.tokens := int(evt.target.value) |> default(DefaultTokens)
								render()
							}
						}, [])
					])
					h(:label, [], [
						h(:span, ['label-text'], ['Completions'])
						h(:input, ['floating'], {
							type: 'number'
							min: '1'
							max: '50'
							value: State.params.n
						}, {
							input: fn(evt) {
								State.params.n := int(evt.target.value) |> default(DefaultN)
								render()
							}
						}, [])
					])
				])
				h(:div, ['right'], [
					if len(State.docs) {
						1 -> ?
						_ -> h(:button, ['floating', 'ai-delete-button'], {}, {
							click: fn {
								State.docs := State.docs |> filter(fn(_, i) i != State.docIdx)
								render()
							}
						}, ['Delete'])
					}
					h(:button, ['floating', 'accent', 'ai-generate-button'], {}, {
						click: updateCompletions
					}, ['Generate'])
				])
			])
			h(:div, ['completions-container'], {
				if State.fetching? {
					true -> [h(:div, ['completions-fetching'], [
						h(:div, ['loading'], [])
					])]
					false -> currentDoc().completions |> with map() fn(completion) {
						[prompt, generated] := completion
						h(:div, ['floating', 'completion'], {}, {
							click: fn {
								currentDoc().prompt := prompt + generated
								render()
							}
						}, [
							h(:span, ['completion-prompt'], [prompt])
							h(:span, ['completion-generated'], [generated])
						])
					}
					_ -> [h(:div, ['completions-error'], [
						'error'
						State.fetching? // error message
					])]
				}
			})
		])
	])
}
render()

